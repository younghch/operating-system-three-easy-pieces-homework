
# Overview

This program allows you to see how address translations are performed in a
system with segmentation. The segmentation that this system uses is pretty
simple: an address space has just *two* segments; further, the top bit of the
virtual address generated by the process determines which segment the address
is in: 0 for segment 0 (where, say, code and the heap would reside) and 1 for
segment 1 (where the stack lives). Segment 0 grows in a positive direction
(towards higher addresses), whereas segment 1 grows in the negative direction.

Visually, the address space looks like this:

```
 --------------- virtual address 0
 |    seg0     |
 |             |
 |             |
 |-------------|
 |             |
 |             |
 |             |
 |             |
 |(unallocated)|
 |             |
 |             |
 |             |
 |-------------|
 |             |
 |    seg1     |
 |-------------| virtual address max (size of address space)
```

With segmentation, as you might recall, there is a base/limit pair of
registers per segment. Thus, in this problem, there are two base/limit
pairs. The segment-0 base tells which physical address the *top* of segment 0
has been placed in physical memory and the limit tells how big the segment is;
the segment-1 base tells where the *bottom* of segment 1 has been placed in
physical memory and the corresponding limit also tells us how big the segment
is (or how far it grows in the negative direction).[detail](https://github.com/remzi-arpacidusseau/ostep-homework/tree/master/vm-segmentation)

# Questions
1. Run with seeds 1, 2, and 3, and compute whether each virtual address generated by the process is in or out of bounds. If in bounds, compute the translation.

    Arguments:
      - seed 1
      - address space size 1k
      - phys mem size 16k

    Base-and-Bounds register information:

      - Base   : 0x0000363c (decimal 13884)
      - Limit  : 290

    Virtual Address Trace:
      - VA  0: 0x0000030e (decimal:  782) --> segmentation violation
      - VA  1: 0x00000105 (decimal:  261) --> 0x00003741
      - VA  2: 0x000001fb (decimal:  507) --> segmentation violation
      - VA  3: 0x000001cc (decimal:  460) --> segmentation violation
      - VA  4: 0x0000029b (decimal:  667) --> segmentation violation

    Arguments:
      - ARG seed 2
      - ARG address space size 1k
      - ARG phys mem size 16k

    Base-and-Bounds register information:

      - Base   : 0x00003ca9 (decimal 15529)
      - Limit  : 500

    Virtual Address Trace:
      - VA  0: 0x00000039 (decimal:   57) --> 0x00003ce2
      - VA  1: 0x00000056 (decimal:   86) --> 0x00003cff
      - VA  2: 0x00000357 (decimal:  855) --> segmentation violation
      - VA  3: 0x000002f1 (decimal:  753) --> segmentation violation
      - VA  4: 0x000002ad (decimal:  685) --> segmentation violation
    

2. Run with these flags:``` -s 0 -n 10```. What value do you have set ```-l``` (the bounds register) to in order to ensure that all the generated virtual addresses are within bounds?

    Arguments:
      - seed 0
      - address space size 1k
      - phys mem size 16k

    Base-and-Bounds register information:

      - Base   : 0x0000360b (decimal 13835)

    Virtual Address Trace:
      - VA  0: 0x00000308 (decimal:  776)
      - VA  1: 0x000001ae (decimal:  430)
      - VA  2: 0x00000109 (decimal:  265)
      - VA  3: 0x0000020b (decimal:  523)
      - VA  4: 0x0000019e (decimal:  414)
      - VA  5: 0x00000322 (decimal:  802)
      - VA  6: 0x00000136 (decimal:  310)
      - VA  7: 0x000001e8 (decimal:  488)
      - VA  8: 0x00000255 (decimal:  597)
      - VA  9: 0x000003a1 (decimal:  929)
    
    Limit should be at least decimal 930 because the largest virtual address is 929.

3. Run with these flags: ```-s 1 -n 10 -l 100```. What is the maximum value that base can be set to, such that the address space still fits into physical memory in its entirety?

    Arguments:
      - seed 1
      - address space size 1k
      - phys mem size 16k

    Base-and-Bounds register information:
      - Limit   : 100

    Maximum value base can be set: memory size - limit = 16k - 100 = 0x00003f9c

4. Run some of the same problems above, but with larger address spaces (-a) and physical memories (-p).

    Maximum value base can be set: memory size - limit

5. What fraction of randomly-generated virtual addresses are valid, as a function of the value of the bounds register? Make a graph from running with different random seeds, with limit values ranging from 0 up to the maximum size of the address space.

    The fraction of valid randomly-generated virtual addresses and a value of bound register will be linearly proportional for bound register size 0 to the address space size(1k). If limit is larger than address space size, all randomly generated address will be valid so portion will be 1.